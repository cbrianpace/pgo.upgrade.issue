time="2021-11-12T16:20:49Z" level=debug msg="debug flag set to true" file="cmd/postgres-operator/main.go:62" func=main.main version=5.0.3-0
time="2021-11-12T16:20:49Z" level=info msg="metrics server is starting to listen" addr=":8080" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/log/deleg.go:130" func="log.(*DelegatingLogger).Info" version=5.0.3-0
time="2021-11-12T16:20:50Z" level=info msg="starting controller runtime manager and will wait for signal to exit" file="cmd/postgres-operator/main.go:83" func=main.main version=5.0.3-0
time="2021-11-12T16:20:50Z" level=info msg="starting metrics server" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/manager/internal.go:385" func="manager.(*controllerManager).serveMetrics.func2" path=/metrics version=5.0.3-0
time="2021-11-12T16:20:50Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:50Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:50Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:51Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:51Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:51Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:51Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:51Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:51Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:51Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:51Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:51Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:51Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:52Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:52Z" level=info msg="Starting EventSource" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:165" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster source="kind source: /, Kind=" version=5.0.3-0
time="2021-11-12T16:20:52Z" level=info msg="Starting Controller" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:173" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:52Z" level=info msg="Starting workers" file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/controller/controller.go:211" func="controller.(*Controller).Start.func1" reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0 worker count=2
time="2021-11-12T16:20:52Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="--- \n+++ \n@@ -9,7 +9,7 @@\n     password_encryption: scram-sha-256\n     restore_command: pgbackrest --stanza=db archive-get %f \"%p\"\n     shared_buffers: 256MB\n-    shared_preload_libraries: pg_stat_statements,pgnodemx\n+    shared_preload_libraries: pg_stat_statements,pgnodemx,pgaudit\n     ssl: 'on'\n     ssl_ca_file: /pgconf/tls/ca.crt\n     ssl_cert_file: /pgconf/tls/tls.crt\nConfiguration changed\n" version=5.0.3-0
time="2021-11-12T16:20:52Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:52Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:52Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:53Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:20:53Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312221 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:20:53Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:53Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:53Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:53Z" level=debug msg="removed PgBouncer objects" file="internal/pgbouncer/postgres.go:110" func=pgbouncer.DisableInPostgreSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=5c9966f6bc stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:54Z" level=debug msg="removed PgBouncer user" file="internal/pgbouncer/postgres.go:124" func=pgbouncer.DisableInPostgreSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=5c9966f6bc stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:54Z" level=debug msg="sql received from exporter" file="internal/pgmonitor/api.go:42" func=pgmonitor.Executor.GetExporterSetupSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84b49c8669 stderr= stdout="-- PG13 pgMonitor Setup\n--\n-- Copyright 2017-2021 Crunchy Data Solutions, Inc. All Rights Reserved.\n--\n\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'ccp_monitoring') THEN\n        CREATE ROLE ccp_monitoring WITH LOGIN;\n    END IF;\n\n    -- The pgmonitor role is required by the pgnodemx extension in PostgreSQL versions 9.5 and 9.6\n    -- and should be removed when upgrading to PostgreSQL 10 and above.\n    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'pgmonitor') THEN\n        DROP ROLE pgmonitor;\n    END IF;\nEND\n$$;\n \nGRANT pg_monitor to ccp_monitoring;\nGRANT pg_execute_server_program TO ccp_monitoring;\n\nALTER ROLE ccp_monitoring SET lock_timeout TO '2min';\n\nCREATE SCHEMA IF NOT EXISTS monitor AUTHORIZATION ccp_monitoring;\n\nDROP TABLE IF EXISTS monitor.pgbackrest_info CASCADE;\nCREATE TABLE IF NOT EXISTS monitor.pgbackrest_info (config_file text NOT NULL, data jsonb NOT NULL, gather_timestamp timestamptz DEFAULT now() NOT NULL);\n-- Force more aggressive autovacuum to avoid table bloat over time\nALTER TABLE monitor.pgbackrest_info SET (autovacuum_analyze_scale_factor = 0, autovacuum_vacuum_scale_factor = 0, autovacuum_vacuum_threshold = 10, autovacuum_analyze_threshold = 10);\n\nDROP FUNCTION IF EXISTS monitor.pgbackrest_info(); -- old version from 2.3\nDROP FUNCTION IF EXISTS monitor.pgbackrest_info(int);\nCREATE OR REPLACE FUNCTION monitor.pgbackrest_info(p_throttle_minutes int DEFAULT 10) RETURNS SETOF monitor.pgbackrest_info\n    LANGUAGE plpgsql\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_gather_timestamp      timestamptz;\nv_throttle              interval;\nv_system_identifier     bigint;\n \nBEGIN\n-- Get pgBackRest info in JSON format\n\nv_throttle := make_interval(mins := p_throttle_minutes);\n\nSELECT COALESCE(max(gather_timestamp), '1970-01-01'::timestamptz) INTO v_gather_timestamp FROM monitor.pgbackrest_info;\n\nIF pg_catalog.pg_is_in_recovery() = 'f' THEN\n    IF ((CURRENT_TIMESTAMP - v_gather_timestamp) > v_throttle) THEN\n\n        -- Ensure table is empty \n        DELETE FROM monitor.pgbackrest_info;\n\n        SELECT system_identifier into v_system_identifier FROM pg_control_system();\n\n        -- Copy data into the table directory from the pgBackRest into command\n        EXECUTE format( $cmd$ COPY monitor.pgbackrest_info (config_file, data) FROM program '/usr/bin/pgbackrest-info.sh %s' WITH (format text,DELIMITER '|') $cmd$, v_system_identifier::text );\n\n    END IF;\nEND IF;\n\nRETURN QUERY SELECT * FROM monitor.pgbackrest_info;\n\nIF NOT FOUND THEN\n    RAISE EXCEPTION 'No backups being returned from pgbackrest info command';\nEND IF;\n\nEND \n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.sequence_status();\nCREATE FUNCTION monitor.sequence_status() RETURNS TABLE (sequence_name text, last_value bigint, slots numeric, used numeric, percent int, cycle boolean, numleft numeric, table_usage text)  \n    LANGUAGE sql SECURITY DEFINER STABLE\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\n\n/* \n * Provide detailed status information of sequences in the current database\n */\n\nWITH default_value_sequences AS (\n    -- Get sequences defined as default values with related table\n    -- Note this subquery can be locked/hung by DDL that affects tables with sequences. \n    --  Use monitor.sequence_exhaustion() to actually monitor for sequences running out\n    SELECT s.seqrelid, c.oid \n    FROM pg_catalog.pg_attribute a\n    JOIN pg_catalog.pg_attrdef ad on (ad.adrelid,ad.adnum) = (a.attrelid,a.attnum)\n    JOIN pg_catalog.pg_class c on a.attrelid = c.oid\n    JOIN pg_catalog.pg_sequence s ON s.seqrelid = regexp_replace(pg_get_expr(ad.adbin,ad.adrelid), $re$^nextval\\('(.+?)'::regclass\\)$$re$, $re$\\1$re$)::regclass\n    WHERE (pg_get_expr(ad.adbin,ad.adrelid)) ~ '^nextval\\('\n), dep_sequences AS (\n    -- Get sequences set as dependencies with related tables (identities)    \n    SELECT s.seqrelid, c.oid\n    FROM pg_catalog.pg_sequence s \n    JOIN pg_catalog.pg_depend d ON s.seqrelid = d.objid\n    JOIN pg_catalog.pg_class c ON d.refobjid = c.oid\n    UNION\n    SELECT seqrelid, oid FROM default_value_sequences\n), all_sequences AS (\n    -- Get any remaining sequences\n    SELECT s.seqrelid AS sequence_oid, ds.oid AS table_oid\n    FROM pg_catalog.pg_sequence s\n    LEFT JOIN dep_sequences ds ON s.seqrelid = ds.seqrelid\n)\nSELECT sequence_name\n    , last_value\n    , slots\n    , used\n    , ROUND(used/slots*100)::int AS percent\n    , cycle\n    , CASE WHEN slots < used THEN 0 ELSE slots - used END AS numleft\n    , table_usage\nFROM (\n     SELECT format('%I.%I',s.schemaname, s.sequencename)::text AS sequence_name\n        , COALESCE(s.last_value,s.min_value) AS last_value\n        , s.cycle\n        , CEIL((s.max_value-min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS slots\n        , CEIL((COALESCE(s.last_value,s.min_value)-s.min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS used\n        , string_agg(a.table_oid::regclass::text, ', ') AS table_usage\n    FROM pg_catalog.pg_sequences s\n    JOIN all_sequences a ON (format('%I.%I', s.schemaname, s.sequencename))::regclass = a.sequence_oid\n    GROUP BY 1,2,3,4,5\n) x \nORDER BY ROUND(used/slots*100) DESC\n\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.sequence_exhaustion(int);\nCREATE FUNCTION monitor.sequence_exhaustion(p_percent integer DEFAULT 75, OUT count bigint)\n    LANGUAGE sql SECURITY DEFINER STABLE\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\n\n/* \n * Returns count of sequences that have used up the % value given via the p_percent parameter (default 75%)\n */\n\nSELECT count(*) AS count\nFROM (\n     SELECT CEIL((s.max_value-min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS slots\n        , CEIL((COALESCE(s.last_value,s.min_value)-s.min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS used\n    FROM pg_catalog.pg_sequences s\n) x \nWHERE (ROUND(used/slots*100)::int) > p_percent;\n\n$function$;\n\n/*\n * Tables and functions for monitoring changes to pg_settings and pg_hba_file_rules system catalogs.\n * Can't just do a raw check for the hash value since Prometheus only records numeric values for alerts\n * Tables allow recording of existing settings so they can be referred back to to see what changed\n * If either checksum function returns 0, then NO settings have changed \n * If either checksum function returns 1, then something has changed since last known valid state\n * For replicas, logging past settings is not possible to compare what may have changed\n * For replicas, by default, it is expected that its settings will match the primary\n * For replicas, if the pg_settings or pg_hba.conf are necessarily different from the primary, a known good hash of that replica's\n    settings can be sent as an argument to the relevant checksum function. Views are provided to easily obtain the hash values used by this monitoring tool. \n * If any known hash parameters are passed to the checksum functions, note that it will override any past hash values stored in the log table when doing comparisons and completely re-evaluate the entire state. This is true even if done on a primary where the current state will then also be logged for comparison if it differs from the given hash.\n */\n\nDROP TABLE IF EXISTS monitor.pg_settings_checksum;\nDROP TABLE IF EXISTS monitor.pg_hba_checksum;\n\nCREATE TABLE monitor.pg_settings_checksum (\n    settings_hash_generated text NOT NULL\n    , settings_hash_known_provided text\n    , settings_string text NOT NULL\n    , created_at timestamptz DEFAULT now() NOT NULL\n    , valid smallint NOT NULL );\n\nCOMMENT ON COLUMN monitor.pg_settings_checksum.valid IS 'Set this column to zero if this group of settings is a valid change';\nCREATE INDEX ON monitor.pg_settings_checksum (created_at);\n\nCREATE TABLE monitor.pg_hba_checksum (\n    hba_hash_generated text NOT NULL\n    , hba_hash_known_provided text\n    , hba_string text NOT NULL\n    , created_at timestamptz DEFAULT now() NOT NULL\n    , valid smallint NOT NULL );\n\nCOMMENT ON COLUMN monitor.pg_hba_checksum.valid IS 'Set this column to zero if this group of settings is a valid change';\nCREATE INDEX ON monitor.pg_hba_checksum (created_at);\n\n\nDROP FUNCTION IF EXISTS monitor.pg_settings_checksum(text);\nCREATE FUNCTION monitor.pg_settings_checksum(p_known_settings_hash text DEFAULT NULL) \n    RETURNS smallint\n    LANGUAGE plpgsql SECURITY DEFINER \n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_is_in_recovery        boolean;\nv_settings_hash         text;\nv_settings_hash_old     text;\nv_settings_match        smallint := 0;\nv_settings_string       text;\nv_settings_string_old   text;\nv_valid                 smallint;\n\nBEGIN\n\nSELECT pg_is_in_recovery() INTO v_is_in_recovery;\n\nSELECT md5_hash\n    , settings_string\nINTO v_settings_hash\n    , v_settings_string\nFROM monitor.pg_settings_hash;\n\nSELECT settings_hash_generated, valid\nINTO v_settings_hash_old, v_valid\nFROM monitor.pg_settings_checksum\nORDER BY created_at DESC LIMIT 1;\n\nIF p_known_settings_hash IS NOT NULL THEN\n    v_settings_hash_old := p_known_settings_hash;\n    -- Do not base validity on the stored value if manual hash is given. \n    v_valid := 0;\nEND IF;\n\nIF (v_settings_hash_old IS NOT NULL) THEN\n\n    IF (v_settings_hash != v_settings_hash_old) THEN\n\n        v_valid := 1;\n\n        IF v_is_in_recovery = false THEN \n            INSERT INTO monitor.pg_settings_checksum (\n                    settings_hash_generated\n                    , settings_hash_known_provided\n                    , settings_string\n                    , valid)\n            VALUES (\n                    v_settings_hash\n                    , p_known_settings_hash\n                    , v_settings_string\n                    , v_valid);\n        END IF;\n    END IF;\n\nELSE\n\n    v_valid := 0;\n    IF v_is_in_recovery = false THEN\n        INSERT INTO monitor.pg_settings_checksum (\n                settings_hash_generated\n                , settings_hash_known_provided\n                , settings_string\n                , valid)\n        VALUES (v_settings_hash\n                , p_known_settings_hash\n                , v_settings_string\n                , v_valid);\n    END IF;\n\nEND IF; \n\nRETURN v_valid;\n\nEND\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_hba_checksum(text);\nCREATE FUNCTION monitor.pg_hba_checksum(p_known_hba_hash text DEFAULT NULL) \n    RETURNS smallint\n    LANGUAGE plpgsql SECURITY DEFINER \n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_hba_hash              text;\nv_hba_hash_old          text;\nv_hba_match             smallint := 0;\nv_hba_string            text;\nv_hba_string_old        text;\nv_is_in_recovery        boolean;\nv_valid                 smallint;\n\nBEGIN\n\nSELECT pg_is_in_recovery() INTO v_is_in_recovery;\n\nIF current_setting('server_version_num')::int >= 100000 THEN\n\n    SELECT md5_hash\n        , hba_string\n    INTO v_hba_hash\n        , v_hba_string\n    FROM monitor.pg_hba_hash;\n\nELSE\n    RAISE EXCEPTION 'pg_hba change monitoring unsupported in versions older than PostgreSQL 10';\nEND IF;\n\nSELECT  hba_hash_generated, valid\nINTO v_hba_hash_old, v_valid\nFROM monitor.pg_hba_checksum\nORDER BY created_at DESC LIMIT 1;\n\nIF p_known_hba_hash IS NOT NULL THEN\n    v_hba_hash_old := p_known_hba_hash;\n    -- Do not base validity on the stored value if manual hash is given. \n    v_valid := 0;\nEND IF;\n\nIF (v_hba_hash_old IS NOT NULL) THEN\n\n    IF (v_hba_hash != v_hba_hash_old) THEN\n\n        v_valid := 1;\n\n        IF v_is_in_recovery = false THEN \n            INSERT INTO monitor.pg_hba_checksum (\n                    hba_hash_generated\n                    , hba_hash_known_provided\n                    , hba_string\n                    , valid)\n            VALUES (\n                    v_hba_hash\n                    , p_known_hba_hash\n                    , v_hba_string\n                    , v_valid);\n        END IF;\n    END IF;\n\nELSE\n\n    v_valid := 0;\n    IF v_is_in_recovery = false THEN\n        INSERT INTO monitor.pg_hba_checksum (\n                hba_hash_generated\n                , hba_hash_known_provided\n                , hba_string\n                , valid)\n        VALUES (v_hba_hash\n                , p_known_hba_hash\n                , v_hba_string\n                , v_valid);\n    END IF;\n\nEND IF; \n\nRETURN v_valid;\n\nEND\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_settings_checksum_set_valid();\n/*\n * This function provides quick, clear interface for resetting the checksum monitor to treat the currently detected configuration as valid after alerting on a change. Note that configuration history will be cleared.\n */\nCREATE FUNCTION monitor.pg_settings_checksum_set_valid() RETURNS smallint\n    LANGUAGE sql \nAS $function$\n\nTRUNCATE monitor.pg_settings_checksum;\n\nSELECT monitor.pg_settings_checksum();\n\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_hba_checksum_set_valid();\n/*\n * This function provides quick, clear interface for resetting the checksum monitor to treat the currently detected configuration as valid after alerting on a change. Note that configuration history will be cleared.\n */\nCREATE FUNCTION monitor.pg_hba_checksum_set_valid() RETURNS smallint\n    LANGUAGE sql \nAS $function$\n\nTRUNCATE monitor.pg_hba_checksum;\n\nSELECT monitor.pg_hba_checksum();\n\n$function$;\n\n\nDROP VIEW IF EXISTS monitor.pg_settings_hash;\nCREATE VIEW monitor.pg_settings_hash AS\n    WITH settings_ordered_list AS (\n        SELECT name\n            , COALESCE(setting, '<<NULL>>') AS setting\n        FROM pg_catalog.pg_settings \n        ORDER BY name, setting)\n    SELECT md5(string_agg(name||setting, ',')) AS md5_hash\n        , string_agg(name||setting, ',') AS settings_string\n    FROM settings_ordered_list;\n\n\nDROP VIEW IF EXISTS monitor.pg_hba_hash;\nCREATE VIEW monitor.pg_hba_hash AS\n    -- Order by line number so it's caught if no content is changed but the order of entries is changed\n    WITH hba_ordered_list AS (\n        SELECT COALESCE(type, '<<NULL>>') AS type\n            , array_to_string(COALESCE(database, ARRAY['<<NULL>>']), ',') AS database\n            , array_to_string(COALESCE(user_name, ARRAY['<<NULL>>']), ',') AS user_name\n            , COALESCE(address, '<<NULL>>') AS address\n            , COALESCE(netmask, '<<NULL>>') AS netmask\n            , COALESCE(auth_method, '<<NULL>>') AS auth_method\n            , array_to_string(COALESCE(options, ARRAY['<<NULL>>']), ',') AS options\n        FROM pg_catalog.pg_hba_file_rules\n        ORDER BY line_number)\n    SELECT md5(string_agg(type||database||user_name||address||netmask||auth_method||options, ',')) AS md5_hash\n        , string_agg(type||database||user_name||address||netmask||auth_method||options, ',') AS hba_string\n    FROM hba_ordered_list;\n\n\n\nDROP TABLE IF EXISTS monitor.pg_stat_statements_reset_info;\n-- Table to store last reset time for pg_stat_statements\nCREATE TABLE monitor.pg_stat_statements_reset_info(\n   reset_time timestamptz \n);\n\nDROP FUNCTION IF EXISTS monitor.pg_stat_statements_reset_info(int);\n-- Function to reset pg_stat_statements periodically\nCREATE FUNCTION monitor.pg_stat_statements_reset_info(p_throttle_minutes integer DEFAULT 1440)\n  RETURNS bigint\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\n  v_reset_timestamp      timestamptz;\n  v_throttle             interval;\n \nBEGIN\n\n  IF p_throttle_minutes < 0 THEN\n      RETURN 0;\n  END IF;\n\n  v_throttle := make_interval(mins := p_throttle_minutes);\n\n  SELECT COALESCE(max(reset_time), '1970-01-01'::timestamptz) INTO v_reset_timestamp FROM monitor.pg_stat_statements_reset_info;\n\n  IF ((CURRENT_TIMESTAMP - v_reset_timestamp) > v_throttle) THEN\n      -- Ensure table is empty \n      DELETE FROM monitor.pg_stat_statements_reset_info;\n      PERFORM pg_stat_statements_reset();\n      INSERT INTO monitor.pg_stat_statements_reset_info(reset_time) values (now());\n  END IF;\n\n  RETURN (SELECT extract(epoch from reset_time) FROM monitor.pg_stat_statements_reset_info);\n\nEXCEPTION \n   WHEN others then \n       RETURN 0;\nEND \n$function$;\n\nGRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA monitor TO ccp_monitoring;\nGRANT ALL ON ALL TABLES IN SCHEMA monitor TO ccp_monitoring;\n" version=5.0.3-0
time="2021-11-12T16:20:54Z" level=debug msg="updated pgMonitor default configration" file="internal/pgmonitor/api.go:55" func=pgmonitor.Executor.GetExporterSetupSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84b49c8669 sql="-- PG13 pgMonitor Setup\n--\n-- Copyright 2017-2021 Crunchy Data Solutions, Inc. All Rights Reserved.\n--\n\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'ccp_monitoring') THEN\n        CREATE ROLE ccp_monitoring WITH LOGIN;\n    END IF;\n\n    -- The pgmonitor role is required by the pgnodemx extension in PostgreSQL versions 9.5 and 9.6\n    -- and should be removed when upgrading to PostgreSQL 10 and above.\n    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'pgmonitor') THEN\n        DROP ROLE pgmonitor;\n    END IF;\nEND\n$$;\n \nGRANT pg_monitor to ccp_monitoring;\nGRANT pg_execute_server_program TO ccp_monitoring;\n\nALTER ROLE ccp_monitoring SET lock_timeout TO '2min';\n\nCREATE SCHEMA IF NOT EXISTS monitor AUTHORIZATION ccp_monitoring;\n\nDROP TABLE IF EXISTS monitor.pgbackrest_info CASCADE;\nCREATE TABLE IF NOT EXISTS monitor.pgbackrest_info (config_file text NOT NULL, data jsonb NOT NULL, gather_timestamp timestamptz DEFAULT now() NOT NULL);\n-- Force more aggressive autovacuum to avoid table bloat over time\nALTER TABLE monitor.pgbackrest_info SET (autovacuum_analyze_scale_factor = 0, autovacuum_vacuum_scale_factor = 0, autovacuum_vacuum_threshold = 10, autovacuum_analyze_threshold = 10);\n\nDROP FUNCTION IF EXISTS monitor.pgbackrest_info(); -- old version from 2.3\nDROP FUNCTION IF EXISTS monitor.pgbackrest_info(int);\nCREATE OR REPLACE FUNCTION monitor.pgbackrest_info(p_throttle_minutes int DEFAULT 10) RETURNS SETOF monitor.pgbackrest_info\n    LANGUAGE plpgsql\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_gather_timestamp      timestamptz;\nv_throttle              interval;\nv_system_identifier     bigint;\n \nBEGIN\n-- Get pgBackRest info in JSON format\n\nv_throttle := make_interval(mins := p_throttle_minutes);\n\nSELECT COALESCE(max(gather_timestamp), '1970-01-01'::timestamptz) INTO v_gather_timestamp FROM monitor.pgbackrest_info;\n\nIF pg_catalog.pg_is_in_recovery() = 'f' THEN\n    IF ((CURRENT_TIMESTAMP - v_gather_timestamp) > v_throttle) THEN\n\n        -- Ensure table is empty \n        DELETE FROM monitor.pgbackrest_info;\n\n        SELECT system_identifier into v_system_identifier FROM pg_control_system();\n\n        -- Copy data into the table directory from the pgBackRest into command\n        EXECUTE format( $cmd$ COPY monitor.pgbackrest_info (config_file, data) FROM program '/opt/crunchy/bin/postgres/pgbackrest_info.sh %s' WITH (format text,DELIMITER '|') $cmd$, v_system_identifier::text );\n\n    END IF;\nEND IF;\n\nRETURN QUERY SELECT * FROM monitor.pgbackrest_info;\n\nIF NOT FOUND THEN\n    RAISE EXCEPTION 'No backups being returned from pgbackrest info command';\nEND IF;\n\nEND \n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.sequence_status();\nCREATE FUNCTION monitor.sequence_status() RETURNS TABLE (sequence_name text, last_value bigint, slots numeric, used numeric, percent int, cycle boolean, numleft numeric, table_usage text)  \n    LANGUAGE sql SECURITY DEFINER STABLE\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\n\n/* \n * Provide detailed status information of sequences in the current database\n */\n\nWITH default_value_sequences AS (\n    -- Get sequences defined as default values with related table\n    -- Note this subquery can be locked/hung by DDL that affects tables with sequences. \n    --  Use monitor.sequence_exhaustion() to actually monitor for sequences running out\n    SELECT s.seqrelid, c.oid \n    FROM pg_catalog.pg_attribute a\n    JOIN pg_catalog.pg_attrdef ad on (ad.adrelid,ad.adnum) = (a.attrelid,a.attnum)\n    JOIN pg_catalog.pg_class c on a.attrelid = c.oid\n    JOIN pg_catalog.pg_sequence s ON s.seqrelid = regexp_replace(pg_get_expr(ad.adbin,ad.adrelid), $re$^nextval\\('(.+?)'::regclass\\)$$re$, $re$\\1$re$)::regclass\n    WHERE (pg_get_expr(ad.adbin,ad.adrelid)) ~ '^nextval\\('\n), dep_sequences AS (\n    -- Get sequences set as dependencies with related tables (identities)    \n    SELECT s.seqrelid, c.oid\n    FROM pg_catalog.pg_sequence s \n    JOIN pg_catalog.pg_depend d ON s.seqrelid = d.objid\n    JOIN pg_catalog.pg_class c ON d.refobjid = c.oid\n    UNION\n    SELECT seqrelid, oid FROM default_value_sequences\n), all_sequences AS (\n    -- Get any remaining sequences\n    SELECT s.seqrelid AS sequence_oid, ds.oid AS table_oid\n    FROM pg_catalog.pg_sequence s\n    LEFT JOIN dep_sequences ds ON s.seqrelid = ds.seqrelid\n)\nSELECT sequence_name\n    , last_value\n    , slots\n    , used\n    , ROUND(used/slots*100)::int AS percent\n    , cycle\n    , CASE WHEN slots < used THEN 0 ELSE slots - used END AS numleft\n    , table_usage\nFROM (\n     SELECT format('%I.%I',s.schemaname, s.sequencename)::text AS sequence_name\n        , COALESCE(s.last_value,s.min_value) AS last_value\n        , s.cycle\n        , CEIL((s.max_value-min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS slots\n        , CEIL((COALESCE(s.last_value,s.min_value)-s.min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS used\n        , string_agg(a.table_oid::regclass::text, ', ') AS table_usage\n    FROM pg_catalog.pg_sequences s\n    JOIN all_sequences a ON (format('%I.%I', s.schemaname, s.sequencename))::regclass = a.sequence_oid\n    GROUP BY 1,2,3,4,5\n) x \nORDER BY ROUND(used/slots*100) DESC\n\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.sequence_exhaustion(int);\nCREATE FUNCTION monitor.sequence_exhaustion(p_percent integer DEFAULT 75, OUT count bigint)\n    LANGUAGE sql SECURITY DEFINER STABLE\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\n\n/* \n * Returns count of sequences that have used up the % value given via the p_percent parameter (default 75%)\n */\n\nSELECT count(*) AS count\nFROM (\n     SELECT CEIL((s.max_value-min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS slots\n        , CEIL((COALESCE(s.last_value,s.min_value)-s.min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS used\n    FROM pg_catalog.pg_sequences s\n) x \nWHERE (ROUND(used/slots*100)::int) > p_percent;\n\n$function$;\n\n/*\n * Tables and functions for monitoring changes to pg_settings and pg_hba_file_rules system catalogs.\n * Can't just do a raw check for the hash value since Prometheus only records numeric values for alerts\n * Tables allow recording of existing settings so they can be referred back to to see what changed\n * If either checksum function returns 0, then NO settings have changed \n * If either checksum function returns 1, then something has changed since last known valid state\n * For replicas, logging past settings is not possible to compare what may have changed\n * For replicas, by default, it is expected that its settings will match the primary\n * For replicas, if the pg_settings or pg_hba.conf are necessarily different from the primary, a known good hash of that replica's\n    settings can be sent as an argument to the relevant checksum function. Views are provided to easily obtain the hash values used by this monitoring tool. \n * If any known hash parameters are passed to the checksum functions, note that it will override any past hash values stored in the log table when doing comparisons and completely re-evaluate the entire state. This is true even if done on a primary where the current state will then also be logged for comparison if it differs from the given hash.\n */\n\nDROP TABLE IF EXISTS monitor.pg_settings_checksum;\nDROP TABLE IF EXISTS monitor.pg_hba_checksum;\n\nCREATE TABLE monitor.pg_settings_checksum (\n    settings_hash_generated text NOT NULL\n    , settings_hash_known_provided text\n    , settings_string text NOT NULL\n    , created_at timestamptz DEFAULT now() NOT NULL\n    , valid smallint NOT NULL );\n\nCOMMENT ON COLUMN monitor.pg_settings_checksum.valid IS 'Set this column to zero if this group of settings is a valid change';\nCREATE INDEX ON monitor.pg_settings_checksum (created_at);\n\nCREATE TABLE monitor.pg_hba_checksum (\n    hba_hash_generated text NOT NULL\n    , hba_hash_known_provided text\n    , hba_string text NOT NULL\n    , created_at timestamptz DEFAULT now() NOT NULL\n    , valid smallint NOT NULL );\n\nCOMMENT ON COLUMN monitor.pg_hba_checksum.valid IS 'Set this column to zero if this group of settings is a valid change';\nCREATE INDEX ON monitor.pg_hba_checksum (created_at);\n\n\nDROP FUNCTION IF EXISTS monitor.pg_settings_checksum(text);\nCREATE FUNCTION monitor.pg_settings_checksum(p_known_settings_hash text DEFAULT NULL) \n    RETURNS smallint\n    LANGUAGE plpgsql SECURITY DEFINER \n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_is_in_recovery        boolean;\nv_settings_hash         text;\nv_settings_hash_old     text;\nv_settings_match        smallint := 0;\nv_settings_string       text;\nv_settings_string_old   text;\nv_valid                 smallint;\n\nBEGIN\n\nSELECT pg_is_in_recovery() INTO v_is_in_recovery;\n\nSELECT md5_hash\n    , settings_string\nINTO v_settings_hash\n    , v_settings_string\nFROM monitor.pg_settings_hash;\n\nSELECT settings_hash_generated, valid\nINTO v_settings_hash_old, v_valid\nFROM monitor.pg_settings_checksum\nORDER BY created_at DESC LIMIT 1;\n\nIF p_known_settings_hash IS NOT NULL THEN\n    v_settings_hash_old := p_known_settings_hash;\n    -- Do not base validity on the stored value if manual hash is given. \n    v_valid := 0;\nEND IF;\n\nIF (v_settings_hash_old IS NOT NULL) THEN\n\n    IF (v_settings_hash != v_settings_hash_old) THEN\n\n        v_valid := 1;\n\n        IF v_is_in_recovery = false THEN \n            INSERT INTO monitor.pg_settings_checksum (\n                    settings_hash_generated\n                    , settings_hash_known_provided\n                    , settings_string\n                    , valid)\n            VALUES (\n                    v_settings_hash\n                    , p_known_settings_hash\n                    , v_settings_string\n                    , v_valid);\n        END IF;\n    END IF;\n\nELSE\n\n    v_valid := 0;\n    IF v_is_in_recovery = false THEN\n        INSERT INTO monitor.pg_settings_checksum (\n                settings_hash_generated\n                , settings_hash_known_provided\n                , settings_string\n                , valid)\n        VALUES (v_settings_hash\n                , p_known_settings_hash\n                , v_settings_string\n                , v_valid);\n    END IF;\n\nEND IF; \n\nRETURN v_valid;\n\nEND\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_hba_checksum(text);\nCREATE FUNCTION monitor.pg_hba_checksum(p_known_hba_hash text DEFAULT NULL) \n    RETURNS smallint\n    LANGUAGE plpgsql SECURITY DEFINER \n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_hba_hash              text;\nv_hba_hash_old          text;\nv_hba_match             smallint := 0;\nv_hba_string            text;\nv_hba_string_old        text;\nv_is_in_recovery        boolean;\nv_valid                 smallint;\n\nBEGIN\n\nSELECT pg_is_in_recovery() INTO v_is_in_recovery;\n\nIF current_setting('server_version_num')::int >= 100000 THEN\n\n    SELECT md5_hash\n        , hba_string\n    INTO v_hba_hash\n        , v_hba_string\n    FROM monitor.pg_hba_hash;\n\nELSE\n    RAISE EXCEPTION 'pg_hba change monitoring unsupported in versions older than PostgreSQL 10';\nEND IF;\n\nSELECT  hba_hash_generated, valid\nINTO v_hba_hash_old, v_valid\nFROM monitor.pg_hba_checksum\nORDER BY created_at DESC LIMIT 1;\n\nIF p_known_hba_hash IS NOT NULL THEN\n    v_hba_hash_old := p_known_hba_hash;\n    -- Do not base validity on the stored value if manual hash is given. \n    v_valid := 0;\nEND IF;\n\nIF (v_hba_hash_old IS NOT NULL) THEN\n\n    IF (v_hba_hash != v_hba_hash_old) THEN\n\n        v_valid := 1;\n\n        IF v_is_in_recovery = false THEN \n            INSERT INTO monitor.pg_hba_checksum (\n                    hba_hash_generated\n                    , hba_hash_known_provided\n                    , hba_string\n                    , valid)\n            VALUES (\n                    v_hba_hash\n                    , p_known_hba_hash\n                    , v_hba_string\n                    , v_valid);\n        END IF;\n    END IF;\n\nELSE\n\n    v_valid := 0;\n    IF v_is_in_recovery = false THEN\n        INSERT INTO monitor.pg_hba_checksum (\n                hba_hash_generated\n                , hba_hash_known_provided\n                , hba_string\n                , valid)\n        VALUES (v_hba_hash\n                , p_known_hba_hash\n                , v_hba_string\n                , v_valid);\n    END IF;\n\nEND IF; \n\nRETURN v_valid;\n\nEND\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_settings_checksum_set_valid();\n/*\n * This function provides quick, clear interface for resetting the checksum monitor to treat the currently detected configuration as valid after alerting on a change. Note that configuration history will be cleared.\n */\nCREATE FUNCTION monitor.pg_settings_checksum_set_valid() RETURNS smallint\n    LANGUAGE sql \nAS $function$\n\nTRUNCATE monitor.pg_settings_checksum;\n\nSELECT monitor.pg_settings_checksum();\n\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_hba_checksum_set_valid();\n/*\n * This function provides quick, clear interface for resetting the checksum monitor to treat the currently detected configuration as valid after alerting on a change. Note that configuration history will be cleared.\n */\nCREATE FUNCTION monitor.pg_hba_checksum_set_valid() RETURNS smallint\n    LANGUAGE sql \nAS $function$\n\nTRUNCATE monitor.pg_hba_checksum;\n\nSELECT monitor.pg_hba_checksum();\n\n$function$;\n\n\nDROP VIEW IF EXISTS monitor.pg_settings_hash;\nCREATE VIEW monitor.pg_settings_hash AS\n    WITH settings_ordered_list AS (\n        SELECT name\n            , COALESCE(setting, '<<NULL>>') AS setting\n        FROM pg_catalog.pg_settings \n        ORDER BY name, setting)\n    SELECT md5(string_agg(name||setting, ',')) AS md5_hash\n        , string_agg(name||setting, ',') AS settings_string\n    FROM settings_ordered_list;\n\n\nDROP VIEW IF EXISTS monitor.pg_hba_hash;\nCREATE VIEW monitor.pg_hba_hash AS\n    -- Order by line number so it's caught if no content is changed but the order of entries is changed\n    WITH hba_ordered_list AS (\n        SELECT COALESCE(type, '<<NULL>>') AS type\n            , array_to_string(COALESCE(database, ARRAY['<<NULL>>']), ',') AS database\n            , array_to_string(COALESCE(user_name, ARRAY['<<NULL>>']), ',') AS user_name\n            , COALESCE(address, '<<NULL>>') AS address\n            , COALESCE(netmask, '<<NULL>>') AS netmask\n            , COALESCE(auth_method, '<<NULL>>') AS auth_method\n            , array_to_string(COALESCE(options, ARRAY['<<NULL>>']), ',') AS options\n        FROM pg_catalog.pg_hba_file_rules\n        ORDER BY line_number)\n    SELECT md5(string_agg(type||database||user_name||address||netmask||auth_method||options, ',')) AS md5_hash\n        , string_agg(type||database||user_name||address||netmask||auth_method||options, ',') AS hba_string\n    FROM hba_ordered_list;\n\n\n\nDROP TABLE IF EXISTS monitor.pg_stat_statements_reset_info;\n-- Table to store last reset time for pg_stat_statements\nCREATE TABLE monitor.pg_stat_statements_reset_info(\n   reset_time timestamptz \n);\n\nDROP FUNCTION IF EXISTS monitor.pg_stat_statements_reset_info(int);\n-- Function to reset pg_stat_statements periodically\nCREATE FUNCTION monitor.pg_stat_statements_reset_info(p_throttle_minutes integer DEFAULT 1440)\n  RETURNS bigint\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\n  v_reset_timestamp      timestamptz;\n  v_throttle             interval;\n \nBEGIN\n\n  IF p_throttle_minutes < 0 THEN\n      RETURN 0;\n  END IF;\n\n  v_throttle := make_interval(mins := p_throttle_minutes);\n\n  SELECT COALESCE(max(reset_time), '1970-01-01'::timestamptz) INTO v_reset_timestamp FROM monitor.pg_stat_statements_reset_info;\n\n  IF ((CURRENT_TIMESTAMP - v_reset_timestamp) > v_throttle) THEN\n      -- Ensure table is empty \n      DELETE FROM monitor.pg_stat_statements_reset_info;\n      PERFORM pg_stat_statements_reset();\n      INSERT INTO monitor.pg_stat_statements_reset_info(reset_time) values (now());\n  END IF;\n\n  RETURN (SELECT extract(epoch from reset_time) FROM monitor.pg_stat_statements_reset_info);\n\nEXCEPTION \n   WHEN others then \n       RETURN 0;\nEND \n$function$;\n\nGRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA monitor TO ccp_monitoring;\nGRANT ALL ON ALL TABLES IN SCHEMA monitor TO ccp_monitoring;\n" version=5.0.3-0
time="2021-11-12T16:20:54Z" level=debug msg="applied pgMonitor objects" database="current and future databases" file="internal/pgmonitor/postgres.go:110" func=pgmonitor.EnableExporterInPostgreSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84b49c8669 stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:54Z" level=debug msg="applied pgMonitor objects" database=postgres file="internal/pgmonitor/postgres.go:146" func=pgmonitor.EnableExporterInPostgreSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84b49c8669 stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:54Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:54Z" level=debug msg="patched cluster status" file="internal/controller/postgrescluster/controller.go:171" func="postgrescluster.(*Reconciler).Reconcile.func2" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:55Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:20:55Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:55Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:55Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:55Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:20:55Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312221 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:20:56Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:56Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:56Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:56Z" level=debug msg="removed PgBouncer objects" file="internal/pgbouncer/postgres.go:110" func=pgbouncer.DisableInPostgreSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=5c9966f6bc stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:56Z" level=debug msg="removed PgBouncer user" file="internal/pgbouncer/postgres.go:124" func=pgbouncer.DisableInPostgreSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=5c9966f6bc stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:56Z" level=debug msg="sql received from exporter" file="internal/pgmonitor/api.go:42" func=pgmonitor.Executor.GetExporterSetupSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84b49c8669 stderr= stdout="-- PG13 pgMonitor Setup\n--\n-- Copyright 2017-2021 Crunchy Data Solutions, Inc. All Rights Reserved.\n--\n\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'ccp_monitoring') THEN\n        CREATE ROLE ccp_monitoring WITH LOGIN;\n    END IF;\n\n    -- The pgmonitor role is required by the pgnodemx extension in PostgreSQL versions 9.5 and 9.6\n    -- and should be removed when upgrading to PostgreSQL 10 and above.\n    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'pgmonitor') THEN\n        DROP ROLE pgmonitor;\n    END IF;\nEND\n$$;\n \nGRANT pg_monitor to ccp_monitoring;\nGRANT pg_execute_server_program TO ccp_monitoring;\n\nALTER ROLE ccp_monitoring SET lock_timeout TO '2min';\n\nCREATE SCHEMA IF NOT EXISTS monitor AUTHORIZATION ccp_monitoring;\n\nDROP TABLE IF EXISTS monitor.pgbackrest_info CASCADE;\nCREATE TABLE IF NOT EXISTS monitor.pgbackrest_info (config_file text NOT NULL, data jsonb NOT NULL, gather_timestamp timestamptz DEFAULT now() NOT NULL);\n-- Force more aggressive autovacuum to avoid table bloat over time\nALTER TABLE monitor.pgbackrest_info SET (autovacuum_analyze_scale_factor = 0, autovacuum_vacuum_scale_factor = 0, autovacuum_vacuum_threshold = 10, autovacuum_analyze_threshold = 10);\n\nDROP FUNCTION IF EXISTS monitor.pgbackrest_info(); -- old version from 2.3\nDROP FUNCTION IF EXISTS monitor.pgbackrest_info(int);\nCREATE OR REPLACE FUNCTION monitor.pgbackrest_info(p_throttle_minutes int DEFAULT 10) RETURNS SETOF monitor.pgbackrest_info\n    LANGUAGE plpgsql\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_gather_timestamp      timestamptz;\nv_throttle              interval;\nv_system_identifier     bigint;\n \nBEGIN\n-- Get pgBackRest info in JSON format\n\nv_throttle := make_interval(mins := p_throttle_minutes);\n\nSELECT COALESCE(max(gather_timestamp), '1970-01-01'::timestamptz) INTO v_gather_timestamp FROM monitor.pgbackrest_info;\n\nIF pg_catalog.pg_is_in_recovery() = 'f' THEN\n    IF ((CURRENT_TIMESTAMP - v_gather_timestamp) > v_throttle) THEN\n\n        -- Ensure table is empty \n        DELETE FROM monitor.pgbackrest_info;\n\n        SELECT system_identifier into v_system_identifier FROM pg_control_system();\n\n        -- Copy data into the table directory from the pgBackRest into command\n        EXECUTE format( $cmd$ COPY monitor.pgbackrest_info (config_file, data) FROM program '/usr/bin/pgbackrest-info.sh %s' WITH (format text,DELIMITER '|') $cmd$, v_system_identifier::text );\n\n    END IF;\nEND IF;\n\nRETURN QUERY SELECT * FROM monitor.pgbackrest_info;\n\nIF NOT FOUND THEN\n    RAISE EXCEPTION 'No backups being returned from pgbackrest info command';\nEND IF;\n\nEND \n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.sequence_status();\nCREATE FUNCTION monitor.sequence_status() RETURNS TABLE (sequence_name text, last_value bigint, slots numeric, used numeric, percent int, cycle boolean, numleft numeric, table_usage text)  \n    LANGUAGE sql SECURITY DEFINER STABLE\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\n\n/* \n * Provide detailed status information of sequences in the current database\n */\n\nWITH default_value_sequences AS (\n    -- Get sequences defined as default values with related table\n    -- Note this subquery can be locked/hung by DDL that affects tables with sequences. \n    --  Use monitor.sequence_exhaustion() to actually monitor for sequences running out\n    SELECT s.seqrelid, c.oid \n    FROM pg_catalog.pg_attribute a\n    JOIN pg_catalog.pg_attrdef ad on (ad.adrelid,ad.adnum) = (a.attrelid,a.attnum)\n    JOIN pg_catalog.pg_class c on a.attrelid = c.oid\n    JOIN pg_catalog.pg_sequence s ON s.seqrelid = regexp_replace(pg_get_expr(ad.adbin,ad.adrelid), $re$^nextval\\('(.+?)'::regclass\\)$$re$, $re$\\1$re$)::regclass\n    WHERE (pg_get_expr(ad.adbin,ad.adrelid)) ~ '^nextval\\('\n), dep_sequences AS (\n    -- Get sequences set as dependencies with related tables (identities)    \n    SELECT s.seqrelid, c.oid\n    FROM pg_catalog.pg_sequence s \n    JOIN pg_catalog.pg_depend d ON s.seqrelid = d.objid\n    JOIN pg_catalog.pg_class c ON d.refobjid = c.oid\n    UNION\n    SELECT seqrelid, oid FROM default_value_sequences\n), all_sequences AS (\n    -- Get any remaining sequences\n    SELECT s.seqrelid AS sequence_oid, ds.oid AS table_oid\n    FROM pg_catalog.pg_sequence s\n    LEFT JOIN dep_sequences ds ON s.seqrelid = ds.seqrelid\n)\nSELECT sequence_name\n    , last_value\n    , slots\n    , used\n    , ROUND(used/slots*100)::int AS percent\n    , cycle\n    , CASE WHEN slots < used THEN 0 ELSE slots - used END AS numleft\n    , table_usage\nFROM (\n     SELECT format('%I.%I',s.schemaname, s.sequencename)::text AS sequence_name\n        , COALESCE(s.last_value,s.min_value) AS last_value\n        , s.cycle\n        , CEIL((s.max_value-min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS slots\n        , CEIL((COALESCE(s.last_value,s.min_value)-s.min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS used\n        , string_agg(a.table_oid::regclass::text, ', ') AS table_usage\n    FROM pg_catalog.pg_sequences s\n    JOIN all_sequences a ON (format('%I.%I', s.schemaname, s.sequencename))::regclass = a.sequence_oid\n    GROUP BY 1,2,3,4,5\n) x \nORDER BY ROUND(used/slots*100) DESC\n\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.sequence_exhaustion(int);\nCREATE FUNCTION monitor.sequence_exhaustion(p_percent integer DEFAULT 75, OUT count bigint)\n    LANGUAGE sql SECURITY DEFINER STABLE\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\n\n/* \n * Returns count of sequences that have used up the % value given via the p_percent parameter (default 75%)\n */\n\nSELECT count(*) AS count\nFROM (\n     SELECT CEIL((s.max_value-min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS slots\n        , CEIL((COALESCE(s.last_value,s.min_value)-s.min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS used\n    FROM pg_catalog.pg_sequences s\n) x \nWHERE (ROUND(used/slots*100)::int) > p_percent;\n\n$function$;\n\n/*\n * Tables and functions for monitoring changes to pg_settings and pg_hba_file_rules system catalogs.\n * Can't just do a raw check for the hash value since Prometheus only records numeric values for alerts\n * Tables allow recording of existing settings so they can be referred back to to see what changed\n * If either checksum function returns 0, then NO settings have changed \n * If either checksum function returns 1, then something has changed since last known valid state\n * For replicas, logging past settings is not possible to compare what may have changed\n * For replicas, by default, it is expected that its settings will match the primary\n * For replicas, if the pg_settings or pg_hba.conf are necessarily different from the primary, a known good hash of that replica's\n    settings can be sent as an argument to the relevant checksum function. Views are provided to easily obtain the hash values used by this monitoring tool. \n * If any known hash parameters are passed to the checksum functions, note that it will override any past hash values stored in the log table when doing comparisons and completely re-evaluate the entire state. This is true even if done on a primary where the current state will then also be logged for comparison if it differs from the given hash.\n */\n\nDROP TABLE IF EXISTS monitor.pg_settings_checksum;\nDROP TABLE IF EXISTS monitor.pg_hba_checksum;\n\nCREATE TABLE monitor.pg_settings_checksum (\n    settings_hash_generated text NOT NULL\n    , settings_hash_known_provided text\n    , settings_string text NOT NULL\n    , created_at timestamptz DEFAULT now() NOT NULL\n    , valid smallint NOT NULL );\n\nCOMMENT ON COLUMN monitor.pg_settings_checksum.valid IS 'Set this column to zero if this group of settings is a valid change';\nCREATE INDEX ON monitor.pg_settings_checksum (created_at);\n\nCREATE TABLE monitor.pg_hba_checksum (\n    hba_hash_generated text NOT NULL\n    , hba_hash_known_provided text\n    , hba_string text NOT NULL\n    , created_at timestamptz DEFAULT now() NOT NULL\n    , valid smallint NOT NULL );\n\nCOMMENT ON COLUMN monitor.pg_hba_checksum.valid IS 'Set this column to zero if this group of settings is a valid change';\nCREATE INDEX ON monitor.pg_hba_checksum (created_at);\n\n\nDROP FUNCTION IF EXISTS monitor.pg_settings_checksum(text);\nCREATE FUNCTION monitor.pg_settings_checksum(p_known_settings_hash text DEFAULT NULL) \n    RETURNS smallint\n    LANGUAGE plpgsql SECURITY DEFINER \n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_is_in_recovery        boolean;\nv_settings_hash         text;\nv_settings_hash_old     text;\nv_settings_match        smallint := 0;\nv_settings_string       text;\nv_settings_string_old   text;\nv_valid                 smallint;\n\nBEGIN\n\nSELECT pg_is_in_recovery() INTO v_is_in_recovery;\n\nSELECT md5_hash\n    , settings_string\nINTO v_settings_hash\n    , v_settings_string\nFROM monitor.pg_settings_hash;\n\nSELECT settings_hash_generated, valid\nINTO v_settings_hash_old, v_valid\nFROM monitor.pg_settings_checksum\nORDER BY created_at DESC LIMIT 1;\n\nIF p_known_settings_hash IS NOT NULL THEN\n    v_settings_hash_old := p_known_settings_hash;\n    -- Do not base validity on the stored value if manual hash is given. \n    v_valid := 0;\nEND IF;\n\nIF (v_settings_hash_old IS NOT NULL) THEN\n\n    IF (v_settings_hash != v_settings_hash_old) THEN\n\n        v_valid := 1;\n\n        IF v_is_in_recovery = false THEN \n            INSERT INTO monitor.pg_settings_checksum (\n                    settings_hash_generated\n                    , settings_hash_known_provided\n                    , settings_string\n                    , valid)\n            VALUES (\n                    v_settings_hash\n                    , p_known_settings_hash\n                    , v_settings_string\n                    , v_valid);\n        END IF;\n    END IF;\n\nELSE\n\n    v_valid := 0;\n    IF v_is_in_recovery = false THEN\n        INSERT INTO monitor.pg_settings_checksum (\n                settings_hash_generated\n                , settings_hash_known_provided\n                , settings_string\n                , valid)\n        VALUES (v_settings_hash\n                , p_known_settings_hash\n                , v_settings_string\n                , v_valid);\n    END IF;\n\nEND IF; \n\nRETURN v_valid;\n\nEND\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_hba_checksum(text);\nCREATE FUNCTION monitor.pg_hba_checksum(p_known_hba_hash text DEFAULT NULL) \n    RETURNS smallint\n    LANGUAGE plpgsql SECURITY DEFINER \n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_hba_hash              text;\nv_hba_hash_old          text;\nv_hba_match             smallint := 0;\nv_hba_string            text;\nv_hba_string_old        text;\nv_is_in_recovery        boolean;\nv_valid                 smallint;\n\nBEGIN\n\nSELECT pg_is_in_recovery() INTO v_is_in_recovery;\n\nIF current_setting('server_version_num')::int >= 100000 THEN\n\n    SELECT md5_hash\n        , hba_string\n    INTO v_hba_hash\n        , v_hba_string\n    FROM monitor.pg_hba_hash;\n\nELSE\n    RAISE EXCEPTION 'pg_hba change monitoring unsupported in versions older than PostgreSQL 10';\nEND IF;\n\nSELECT  hba_hash_generated, valid\nINTO v_hba_hash_old, v_valid\nFROM monitor.pg_hba_checksum\nORDER BY created_at DESC LIMIT 1;\n\nIF p_known_hba_hash IS NOT NULL THEN\n    v_hba_hash_old := p_known_hba_hash;\n    -- Do not base validity on the stored value if manual hash is given. \n    v_valid := 0;\nEND IF;\n\nIF (v_hba_hash_old IS NOT NULL) THEN\n\n    IF (v_hba_hash != v_hba_hash_old) THEN\n\n        v_valid := 1;\n\n        IF v_is_in_recovery = false THEN \n            INSERT INTO monitor.pg_hba_checksum (\n                    hba_hash_generated\n                    , hba_hash_known_provided\n                    , hba_string\n                    , valid)\n            VALUES (\n                    v_hba_hash\n                    , p_known_hba_hash\n                    , v_hba_string\n                    , v_valid);\n        END IF;\n    END IF;\n\nELSE\n\n    v_valid := 0;\n    IF v_is_in_recovery = false THEN\n        INSERT INTO monitor.pg_hba_checksum (\n                hba_hash_generated\n                , hba_hash_known_provided\n                , hba_string\n                , valid)\n        VALUES (v_hba_hash\n                , p_known_hba_hash\n                , v_hba_string\n                , v_valid);\n    END IF;\n\nEND IF; \n\nRETURN v_valid;\n\nEND\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_settings_checksum_set_valid();\n/*\n * This function provides quick, clear interface for resetting the checksum monitor to treat the currently detected configuration as valid after alerting on a change. Note that configuration history will be cleared.\n */\nCREATE FUNCTION monitor.pg_settings_checksum_set_valid() RETURNS smallint\n    LANGUAGE sql \nAS $function$\n\nTRUNCATE monitor.pg_settings_checksum;\n\nSELECT monitor.pg_settings_checksum();\n\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_hba_checksum_set_valid();\n/*\n * This function provides quick, clear interface for resetting the checksum monitor to treat the currently detected configuration as valid after alerting on a change. Note that configuration history will be cleared.\n */\nCREATE FUNCTION monitor.pg_hba_checksum_set_valid() RETURNS smallint\n    LANGUAGE sql \nAS $function$\n\nTRUNCATE monitor.pg_hba_checksum;\n\nSELECT monitor.pg_hba_checksum();\n\n$function$;\n\n\nDROP VIEW IF EXISTS monitor.pg_settings_hash;\nCREATE VIEW monitor.pg_settings_hash AS\n    WITH settings_ordered_list AS (\n        SELECT name\n            , COALESCE(setting, '<<NULL>>') AS setting\n        FROM pg_catalog.pg_settings \n        ORDER BY name, setting)\n    SELECT md5(string_agg(name||setting, ',')) AS md5_hash\n        , string_agg(name||setting, ',') AS settings_string\n    FROM settings_ordered_list;\n\n\nDROP VIEW IF EXISTS monitor.pg_hba_hash;\nCREATE VIEW monitor.pg_hba_hash AS\n    -- Order by line number so it's caught if no content is changed but the order of entries is changed\n    WITH hba_ordered_list AS (\n        SELECT COALESCE(type, '<<NULL>>') AS type\n            , array_to_string(COALESCE(database, ARRAY['<<NULL>>']), ',') AS database\n            , array_to_string(COALESCE(user_name, ARRAY['<<NULL>>']), ',') AS user_name\n            , COALESCE(address, '<<NULL>>') AS address\n            , COALESCE(netmask, '<<NULL>>') AS netmask\n            , COALESCE(auth_method, '<<NULL>>') AS auth_method\n            , array_to_string(COALESCE(options, ARRAY['<<NULL>>']), ',') AS options\n        FROM pg_catalog.pg_hba_file_rules\n        ORDER BY line_number)\n    SELECT md5(string_agg(type||database||user_name||address||netmask||auth_method||options, ',')) AS md5_hash\n        , string_agg(type||database||user_name||address||netmask||auth_method||options, ',') AS hba_string\n    FROM hba_ordered_list;\n\n\n\nDROP TABLE IF EXISTS monitor.pg_stat_statements_reset_info;\n-- Table to store last reset time for pg_stat_statements\nCREATE TABLE monitor.pg_stat_statements_reset_info(\n   reset_time timestamptz \n);\n\nDROP FUNCTION IF EXISTS monitor.pg_stat_statements_reset_info(int);\n-- Function to reset pg_stat_statements periodically\nCREATE FUNCTION monitor.pg_stat_statements_reset_info(p_throttle_minutes integer DEFAULT 1440)\n  RETURNS bigint\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\n  v_reset_timestamp      timestamptz;\n  v_throttle             interval;\n \nBEGIN\n\n  IF p_throttle_minutes < 0 THEN\n      RETURN 0;\n  END IF;\n\n  v_throttle := make_interval(mins := p_throttle_minutes);\n\n  SELECT COALESCE(max(reset_time), '1970-01-01'::timestamptz) INTO v_reset_timestamp FROM monitor.pg_stat_statements_reset_info;\n\n  IF ((CURRENT_TIMESTAMP - v_reset_timestamp) > v_throttle) THEN\n      -- Ensure table is empty \n      DELETE FROM monitor.pg_stat_statements_reset_info;\n      PERFORM pg_stat_statements_reset();\n      INSERT INTO monitor.pg_stat_statements_reset_info(reset_time) values (now());\n  END IF;\n\n  RETURN (SELECT extract(epoch from reset_time) FROM monitor.pg_stat_statements_reset_info);\n\nEXCEPTION \n   WHEN others then \n       RETURN 0;\nEND \n$function$;\n\nGRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA monitor TO ccp_monitoring;\nGRANT ALL ON ALL TABLES IN SCHEMA monitor TO ccp_monitoring;\n" version=5.0.3-0
time="2021-11-12T16:20:56Z" level=debug msg="updated pgMonitor default configration" file="internal/pgmonitor/api.go:55" func=pgmonitor.Executor.GetExporterSetupSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84b49c8669 sql="-- PG13 pgMonitor Setup\n--\n-- Copyright 2017-2021 Crunchy Data Solutions, Inc. All Rights Reserved.\n--\n\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'ccp_monitoring') THEN\n        CREATE ROLE ccp_monitoring WITH LOGIN;\n    END IF;\n\n    -- The pgmonitor role is required by the pgnodemx extension in PostgreSQL versions 9.5 and 9.6\n    -- and should be removed when upgrading to PostgreSQL 10 and above.\n    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'pgmonitor') THEN\n        DROP ROLE pgmonitor;\n    END IF;\nEND\n$$;\n \nGRANT pg_monitor to ccp_monitoring;\nGRANT pg_execute_server_program TO ccp_monitoring;\n\nALTER ROLE ccp_monitoring SET lock_timeout TO '2min';\n\nCREATE SCHEMA IF NOT EXISTS monitor AUTHORIZATION ccp_monitoring;\n\nDROP TABLE IF EXISTS monitor.pgbackrest_info CASCADE;\nCREATE TABLE IF NOT EXISTS monitor.pgbackrest_info (config_file text NOT NULL, data jsonb NOT NULL, gather_timestamp timestamptz DEFAULT now() NOT NULL);\n-- Force more aggressive autovacuum to avoid table bloat over time\nALTER TABLE monitor.pgbackrest_info SET (autovacuum_analyze_scale_factor = 0, autovacuum_vacuum_scale_factor = 0, autovacuum_vacuum_threshold = 10, autovacuum_analyze_threshold = 10);\n\nDROP FUNCTION IF EXISTS monitor.pgbackrest_info(); -- old version from 2.3\nDROP FUNCTION IF EXISTS monitor.pgbackrest_info(int);\nCREATE OR REPLACE FUNCTION monitor.pgbackrest_info(p_throttle_minutes int DEFAULT 10) RETURNS SETOF monitor.pgbackrest_info\n    LANGUAGE plpgsql\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_gather_timestamp      timestamptz;\nv_throttle              interval;\nv_system_identifier     bigint;\n \nBEGIN\n-- Get pgBackRest info in JSON format\n\nv_throttle := make_interval(mins := p_throttle_minutes);\n\nSELECT COALESCE(max(gather_timestamp), '1970-01-01'::timestamptz) INTO v_gather_timestamp FROM monitor.pgbackrest_info;\n\nIF pg_catalog.pg_is_in_recovery() = 'f' THEN\n    IF ((CURRENT_TIMESTAMP - v_gather_timestamp) > v_throttle) THEN\n\n        -- Ensure table is empty \n        DELETE FROM monitor.pgbackrest_info;\n\n        SELECT system_identifier into v_system_identifier FROM pg_control_system();\n\n        -- Copy data into the table directory from the pgBackRest into command\n        EXECUTE format( $cmd$ COPY monitor.pgbackrest_info (config_file, data) FROM program '/opt/crunchy/bin/postgres/pgbackrest_info.sh %s' WITH (format text,DELIMITER '|') $cmd$, v_system_identifier::text );\n\n    END IF;\nEND IF;\n\nRETURN QUERY SELECT * FROM monitor.pgbackrest_info;\n\nIF NOT FOUND THEN\n    RAISE EXCEPTION 'No backups being returned from pgbackrest info command';\nEND IF;\n\nEND \n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.sequence_status();\nCREATE FUNCTION monitor.sequence_status() RETURNS TABLE (sequence_name text, last_value bigint, slots numeric, used numeric, percent int, cycle boolean, numleft numeric, table_usage text)  \n    LANGUAGE sql SECURITY DEFINER STABLE\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\n\n/* \n * Provide detailed status information of sequences in the current database\n */\n\nWITH default_value_sequences AS (\n    -- Get sequences defined as default values with related table\n    -- Note this subquery can be locked/hung by DDL that affects tables with sequences. \n    --  Use monitor.sequence_exhaustion() to actually monitor for sequences running out\n    SELECT s.seqrelid, c.oid \n    FROM pg_catalog.pg_attribute a\n    JOIN pg_catalog.pg_attrdef ad on (ad.adrelid,ad.adnum) = (a.attrelid,a.attnum)\n    JOIN pg_catalog.pg_class c on a.attrelid = c.oid\n    JOIN pg_catalog.pg_sequence s ON s.seqrelid = regexp_replace(pg_get_expr(ad.adbin,ad.adrelid), $re$^nextval\\('(.+?)'::regclass\\)$$re$, $re$\\1$re$)::regclass\n    WHERE (pg_get_expr(ad.adbin,ad.adrelid)) ~ '^nextval\\('\n), dep_sequences AS (\n    -- Get sequences set as dependencies with related tables (identities)    \n    SELECT s.seqrelid, c.oid\n    FROM pg_catalog.pg_sequence s \n    JOIN pg_catalog.pg_depend d ON s.seqrelid = d.objid\n    JOIN pg_catalog.pg_class c ON d.refobjid = c.oid\n    UNION\n    SELECT seqrelid, oid FROM default_value_sequences\n), all_sequences AS (\n    -- Get any remaining sequences\n    SELECT s.seqrelid AS sequence_oid, ds.oid AS table_oid\n    FROM pg_catalog.pg_sequence s\n    LEFT JOIN dep_sequences ds ON s.seqrelid = ds.seqrelid\n)\nSELECT sequence_name\n    , last_value\n    , slots\n    , used\n    , ROUND(used/slots*100)::int AS percent\n    , cycle\n    , CASE WHEN slots < used THEN 0 ELSE slots - used END AS numleft\n    , table_usage\nFROM (\n     SELECT format('%I.%I',s.schemaname, s.sequencename)::text AS sequence_name\n        , COALESCE(s.last_value,s.min_value) AS last_value\n        , s.cycle\n        , CEIL((s.max_value-min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS slots\n        , CEIL((COALESCE(s.last_value,s.min_value)-s.min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS used\n        , string_agg(a.table_oid::regclass::text, ', ') AS table_usage\n    FROM pg_catalog.pg_sequences s\n    JOIN all_sequences a ON (format('%I.%I', s.schemaname, s.sequencename))::regclass = a.sequence_oid\n    GROUP BY 1,2,3,4,5\n) x \nORDER BY ROUND(used/slots*100) DESC\n\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.sequence_exhaustion(int);\nCREATE FUNCTION monitor.sequence_exhaustion(p_percent integer DEFAULT 75, OUT count bigint)\n    LANGUAGE sql SECURITY DEFINER STABLE\n    SET search_path TO pg_catalog, pg_temp\nAS $function$\n\n/* \n * Returns count of sequences that have used up the % value given via the p_percent parameter (default 75%)\n */\n\nSELECT count(*) AS count\nFROM (\n     SELECT CEIL((s.max_value-min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS slots\n        , CEIL((COALESCE(s.last_value,s.min_value)-s.min_value::NUMERIC+1)/s.increment_by::NUMERIC) AS used\n    FROM pg_catalog.pg_sequences s\n) x \nWHERE (ROUND(used/slots*100)::int) > p_percent;\n\n$function$;\n\n/*\n * Tables and functions for monitoring changes to pg_settings and pg_hba_file_rules system catalogs.\n * Can't just do a raw check for the hash value since Prometheus only records numeric values for alerts\n * Tables allow recording of existing settings so they can be referred back to to see what changed\n * If either checksum function returns 0, then NO settings have changed \n * If either checksum function returns 1, then something has changed since last known valid state\n * For replicas, logging past settings is not possible to compare what may have changed\n * For replicas, by default, it is expected that its settings will match the primary\n * For replicas, if the pg_settings or pg_hba.conf are necessarily different from the primary, a known good hash of that replica's\n    settings can be sent as an argument to the relevant checksum function. Views are provided to easily obtain the hash values used by this monitoring tool. \n * If any known hash parameters are passed to the checksum functions, note that it will override any past hash values stored in the log table when doing comparisons and completely re-evaluate the entire state. This is true even if done on a primary where the current state will then also be logged for comparison if it differs from the given hash.\n */\n\nDROP TABLE IF EXISTS monitor.pg_settings_checksum;\nDROP TABLE IF EXISTS monitor.pg_hba_checksum;\n\nCREATE TABLE monitor.pg_settings_checksum (\n    settings_hash_generated text NOT NULL\n    , settings_hash_known_provided text\n    , settings_string text NOT NULL\n    , created_at timestamptz DEFAULT now() NOT NULL\n    , valid smallint NOT NULL );\n\nCOMMENT ON COLUMN monitor.pg_settings_checksum.valid IS 'Set this column to zero if this group of settings is a valid change';\nCREATE INDEX ON monitor.pg_settings_checksum (created_at);\n\nCREATE TABLE monitor.pg_hba_checksum (\n    hba_hash_generated text NOT NULL\n    , hba_hash_known_provided text\n    , hba_string text NOT NULL\n    , created_at timestamptz DEFAULT now() NOT NULL\n    , valid smallint NOT NULL );\n\nCOMMENT ON COLUMN monitor.pg_hba_checksum.valid IS 'Set this column to zero if this group of settings is a valid change';\nCREATE INDEX ON monitor.pg_hba_checksum (created_at);\n\n\nDROP FUNCTION IF EXISTS monitor.pg_settings_checksum(text);\nCREATE FUNCTION monitor.pg_settings_checksum(p_known_settings_hash text DEFAULT NULL) \n    RETURNS smallint\n    LANGUAGE plpgsql SECURITY DEFINER \n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_is_in_recovery        boolean;\nv_settings_hash         text;\nv_settings_hash_old     text;\nv_settings_match        smallint := 0;\nv_settings_string       text;\nv_settings_string_old   text;\nv_valid                 smallint;\n\nBEGIN\n\nSELECT pg_is_in_recovery() INTO v_is_in_recovery;\n\nSELECT md5_hash\n    , settings_string\nINTO v_settings_hash\n    , v_settings_string\nFROM monitor.pg_settings_hash;\n\nSELECT settings_hash_generated, valid\nINTO v_settings_hash_old, v_valid\nFROM monitor.pg_settings_checksum\nORDER BY created_at DESC LIMIT 1;\n\nIF p_known_settings_hash IS NOT NULL THEN\n    v_settings_hash_old := p_known_settings_hash;\n    -- Do not base validity on the stored value if manual hash is given. \n    v_valid := 0;\nEND IF;\n\nIF (v_settings_hash_old IS NOT NULL) THEN\n\n    IF (v_settings_hash != v_settings_hash_old) THEN\n\n        v_valid := 1;\n\n        IF v_is_in_recovery = false THEN \n            INSERT INTO monitor.pg_settings_checksum (\n                    settings_hash_generated\n                    , settings_hash_known_provided\n                    , settings_string\n                    , valid)\n            VALUES (\n                    v_settings_hash\n                    , p_known_settings_hash\n                    , v_settings_string\n                    , v_valid);\n        END IF;\n    END IF;\n\nELSE\n\n    v_valid := 0;\n    IF v_is_in_recovery = false THEN\n        INSERT INTO monitor.pg_settings_checksum (\n                settings_hash_generated\n                , settings_hash_known_provided\n                , settings_string\n                , valid)\n        VALUES (v_settings_hash\n                , p_known_settings_hash\n                , v_settings_string\n                , v_valid);\n    END IF;\n\nEND IF; \n\nRETURN v_valid;\n\nEND\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_hba_checksum(text);\nCREATE FUNCTION monitor.pg_hba_checksum(p_known_hba_hash text DEFAULT NULL) \n    RETURNS smallint\n    LANGUAGE plpgsql SECURITY DEFINER \n    SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\nv_hba_hash              text;\nv_hba_hash_old          text;\nv_hba_match             smallint := 0;\nv_hba_string            text;\nv_hba_string_old        text;\nv_is_in_recovery        boolean;\nv_valid                 smallint;\n\nBEGIN\n\nSELECT pg_is_in_recovery() INTO v_is_in_recovery;\n\nIF current_setting('server_version_num')::int >= 100000 THEN\n\n    SELECT md5_hash\n        , hba_string\n    INTO v_hba_hash\n        , v_hba_string\n    FROM monitor.pg_hba_hash;\n\nELSE\n    RAISE EXCEPTION 'pg_hba change monitoring unsupported in versions older than PostgreSQL 10';\nEND IF;\n\nSELECT  hba_hash_generated, valid\nINTO v_hba_hash_old, v_valid\nFROM monitor.pg_hba_checksum\nORDER BY created_at DESC LIMIT 1;\n\nIF p_known_hba_hash IS NOT NULL THEN\n    v_hba_hash_old := p_known_hba_hash;\n    -- Do not base validity on the stored value if manual hash is given. \n    v_valid := 0;\nEND IF;\n\nIF (v_hba_hash_old IS NOT NULL) THEN\n\n    IF (v_hba_hash != v_hba_hash_old) THEN\n\n        v_valid := 1;\n\n        IF v_is_in_recovery = false THEN \n            INSERT INTO monitor.pg_hba_checksum (\n                    hba_hash_generated\n                    , hba_hash_known_provided\n                    , hba_string\n                    , valid)\n            VALUES (\n                    v_hba_hash\n                    , p_known_hba_hash\n                    , v_hba_string\n                    , v_valid);\n        END IF;\n    END IF;\n\nELSE\n\n    v_valid := 0;\n    IF v_is_in_recovery = false THEN\n        INSERT INTO monitor.pg_hba_checksum (\n                hba_hash_generated\n                , hba_hash_known_provided\n                , hba_string\n                , valid)\n        VALUES (v_hba_hash\n                , p_known_hba_hash\n                , v_hba_string\n                , v_valid);\n    END IF;\n\nEND IF; \n\nRETURN v_valid;\n\nEND\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_settings_checksum_set_valid();\n/*\n * This function provides quick, clear interface for resetting the checksum monitor to treat the currently detected configuration as valid after alerting on a change. Note that configuration history will be cleared.\n */\nCREATE FUNCTION monitor.pg_settings_checksum_set_valid() RETURNS smallint\n    LANGUAGE sql \nAS $function$\n\nTRUNCATE monitor.pg_settings_checksum;\n\nSELECT monitor.pg_settings_checksum();\n\n$function$;\n\n\nDROP FUNCTION IF EXISTS monitor.pg_hba_checksum_set_valid();\n/*\n * This function provides quick, clear interface for resetting the checksum monitor to treat the currently detected configuration as valid after alerting on a change. Note that configuration history will be cleared.\n */\nCREATE FUNCTION monitor.pg_hba_checksum_set_valid() RETURNS smallint\n    LANGUAGE sql \nAS $function$\n\nTRUNCATE monitor.pg_hba_checksum;\n\nSELECT monitor.pg_hba_checksum();\n\n$function$;\n\n\nDROP VIEW IF EXISTS monitor.pg_settings_hash;\nCREATE VIEW monitor.pg_settings_hash AS\n    WITH settings_ordered_list AS (\n        SELECT name\n            , COALESCE(setting, '<<NULL>>') AS setting\n        FROM pg_catalog.pg_settings \n        ORDER BY name, setting)\n    SELECT md5(string_agg(name||setting, ',')) AS md5_hash\n        , string_agg(name||setting, ',') AS settings_string\n    FROM settings_ordered_list;\n\n\nDROP VIEW IF EXISTS monitor.pg_hba_hash;\nCREATE VIEW monitor.pg_hba_hash AS\n    -- Order by line number so it's caught if no content is changed but the order of entries is changed\n    WITH hba_ordered_list AS (\n        SELECT COALESCE(type, '<<NULL>>') AS type\n            , array_to_string(COALESCE(database, ARRAY['<<NULL>>']), ',') AS database\n            , array_to_string(COALESCE(user_name, ARRAY['<<NULL>>']), ',') AS user_name\n            , COALESCE(address, '<<NULL>>') AS address\n            , COALESCE(netmask, '<<NULL>>') AS netmask\n            , COALESCE(auth_method, '<<NULL>>') AS auth_method\n            , array_to_string(COALESCE(options, ARRAY['<<NULL>>']), ',') AS options\n        FROM pg_catalog.pg_hba_file_rules\n        ORDER BY line_number)\n    SELECT md5(string_agg(type||database||user_name||address||netmask||auth_method||options, ',')) AS md5_hash\n        , string_agg(type||database||user_name||address||netmask||auth_method||options, ',') AS hba_string\n    FROM hba_ordered_list;\n\n\n\nDROP TABLE IF EXISTS monitor.pg_stat_statements_reset_info;\n-- Table to store last reset time for pg_stat_statements\nCREATE TABLE monitor.pg_stat_statements_reset_info(\n   reset_time timestamptz \n);\n\nDROP FUNCTION IF EXISTS monitor.pg_stat_statements_reset_info(int);\n-- Function to reset pg_stat_statements periodically\nCREATE FUNCTION monitor.pg_stat_statements_reset_info(p_throttle_minutes integer DEFAULT 1440)\n  RETURNS bigint\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path TO pg_catalog, pg_temp\nAS $function$\nDECLARE\n\n  v_reset_timestamp      timestamptz;\n  v_throttle             interval;\n \nBEGIN\n\n  IF p_throttle_minutes < 0 THEN\n      RETURN 0;\n  END IF;\n\n  v_throttle := make_interval(mins := p_throttle_minutes);\n\n  SELECT COALESCE(max(reset_time), '1970-01-01'::timestamptz) INTO v_reset_timestamp FROM monitor.pg_stat_statements_reset_info;\n\n  IF ((CURRENT_TIMESTAMP - v_reset_timestamp) > v_throttle) THEN\n      -- Ensure table is empty \n      DELETE FROM monitor.pg_stat_statements_reset_info;\n      PERFORM pg_stat_statements_reset();\n      INSERT INTO monitor.pg_stat_statements_reset_info(reset_time) values (now());\n  END IF;\n\n  RETURN (SELECT extract(epoch from reset_time) FROM monitor.pg_stat_statements_reset_info);\n\nEXCEPTION \n   WHEN others then \n       RETURN 0;\nEND \n$function$;\n\nGRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA monitor TO ccp_monitoring;\nGRANT ALL ON ALL TABLES IN SCHEMA monitor TO ccp_monitoring;\n" version=5.0.3-0
time="2021-11-12T16:20:56Z" level=debug msg="applied pgMonitor objects" database="current and future databases" file="internal/pgmonitor/postgres.go:110" func=pgmonitor.EnableExporterInPostgreSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84b49c8669 stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:57Z" level=debug msg="applied pgMonitor objects" database=postgres file="internal/pgmonitor/postgres.go:146" func=pgmonitor.EnableExporterInPostgreSQL name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84b49c8669 stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:57Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:57Z" level=debug msg="patched cluster status" file="internal/controller/postgrescluster/controller.go:171" func="postgrescluster.(*Reconciler).Reconcile.func2" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:57Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:20:57Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:57Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:57Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:58Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:20:58Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312463 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:20:58Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:58Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:58Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:58Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:58Z" level=debug msg="patched cluster status" file="internal/controller/postgrescluster/controller.go:171" func="postgrescluster.(*Reconciler).Reconcile.func2" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:58Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:20:58Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:58Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:58Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:59Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:20:59Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312463 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:20:59Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:20:59Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:59Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:59Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:20:59Z" level=debug msg="patched cluster status" file="internal/controller/postgrescluster/controller.go:171" func="postgrescluster.(*Reconciler).Reconcile.func2" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:00Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:21:00Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:00Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:00Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:00Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:21:00Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312478 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:21:00Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:21:00Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:00Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:00Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:01Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:21:01Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:01Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:01Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:01Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:21:01Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312478 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:21:01Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:21:01Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:01Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:01Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:02Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:21:02Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:02Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:02Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:02Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:21:02Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312478 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:21:02Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:21:02Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:02Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:02Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:03Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:21:03Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:03Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:03Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:03Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:21:03Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312478 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:21:04Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:21:04Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:04Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:04Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:04Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:21:04Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:04Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:04Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:05Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:21:05Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312478 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:21:05Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:21:05Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:05Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:05Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:05Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:21:05Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:06Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:06Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:06Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:21:06Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312478 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:21:06Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:21:06Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:06Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:06Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:07Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:21:07Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:07Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:07Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:07Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:21:07Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312478 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:21:07Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:21:07Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:07Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:07Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:08Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:21:08Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:08Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:08Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:08Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:21:08Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312478 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:21:08Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:21:09Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:09Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:09Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:09Z" level=debug msg="patched cluster status" file="internal/controller/postgrescluster/controller.go:171" func="postgrescluster.(*Reconciler).Reconcile.func2" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:09Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:21:09Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:09Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:09Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:09Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:21:09Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312539 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:21:10Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:21:10Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:10Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:10Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:13Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:21:13Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:13Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:13Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:13Z" level=debug msg="enabled pgAudit" file="internal/pgaudit/postgres.go:58" func=pgaudit.EnableInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr="psql:<stdin>:1: ERROR:  pgaudit must be loaded via shared_preload_libraries\n" stdout= version=5.0.3-0
time="2021-11-12T16:21:13Z" level=debug msg=Warning file="sigs.k8s.io/controller-runtime@v0.8.3/pkg/internal/recorder/recorder.go:98" func="recorder.(*Provider).getBroadcaster.func1.1" message="Unable to install pgAudit; try restarting PostgreSQL" object="{PostgresCluster finance acctdev 5239a5fb-6e49-4f4c-863c-a2a3e3c83b44 postgres-operator.crunchydata.com/v1beta1 26312539 }" reason=pgAuditDisabled version=5.0.3-0
time="2021-11-12T16:21:14Z" level=debug msg="created PostgreSQL databases" file="internal/postgres/databases.go:80" func=postgres.CreateDatabasesInPostgreSQL name=acctdev namespace=finance pod=acctdev-pgc-gdrq-0 reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster revision=84f99dd6fb stderr= stdout= version=5.0.3-0
time="2021-11-12T16:21:14Z" level=error msg="reconciling repository host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1749" func="postgrescluster.(*Reconciler).reconcileDedicatedRepoHost" name=acctdev namespace=finance reconcileResource=repoHost reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:14Z" level=error msg="unable to reconcile pgBackRest repo host" error="StatefulSet.apps \"acctdev-repo-host\" is invalid: spec: Forbidden: updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden" file="internal/controller/postgrescluster/pgbackrest.go:1218" func="postgrescluster.(*Reconciler).reconcilePGBackRest" name=acctdev namespace=finance reconciler=pgBackRest reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:14Z" level=debug msg="reconciled cluster" file="internal/controller/postgrescluster/controller.go:299" func="postgrescluster.(*Reconciler).Reconcile" name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:55Z" level=debug msg="replaced configuration" file="internal/patroni/api.go:86" func=patroni.Executor.ReplaceConfiguration name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster stderr= stdout="Not changed\n" version=5.0.3-0
time="2021-11-12T16:21:55Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-gdrq name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:55Z" level=debug msg="reconciled instance" file="internal/controller/postgrescluster/instance.go:1094" func="postgrescluster.(*Reconciler).reconcileInstance" instance=acctdev-pgc-5fq4 name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
time="2021-11-12T16:21:55Z" level=debug msg="reconciled instance set" file="internal/controller/postgrescluster/instance.go:988" func="postgrescluster.(*Reconciler).scaleUpInstances" instance-set=pgc name=acctdev namespace=finance reconciler group=postgres-operator.crunchydata.com reconciler kind=PostgresCluster version=5.0.3-0
